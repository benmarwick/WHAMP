# Momentary degree and concurrency {#degree}
```{r, echo=FALSE, include=FALSE}
####################################################################################
# Setup
####################################################################################
#-----------------------------------------------------------------------------------
# Load packages
#-----------------------------------------------------------------------------------

    library("tidyverse")
    library("ggplot2")
    library("survey")
    library("knitr")
    library("xtable")
    library("kableExtra")

#-----------------------------------------------------------------------------------
# Load data
#-----------------------------------------------------------------------------------
    load(file="Data/InternetSurveySample.Rdata")
    load(file="Data/InternetSurvey_reweighted_all.Rdata")
    load(file="Data/InternetSurvey_reweighted_neg.Rdata")

# Set options
    opts_chunk$set(echo=FALSE, message=FALSE, warning=FALSE)
    options(knitr.table.format = "html") 
  
#-----------------------------------------------------------------------------------
# Change degree_main variable to factor and add labels have character labels
#-----------------------------------------------------------------------------------
    sample_rake_all$variables$degree_main <- factor(sample_rake_all$variables$degree_main, levels = c(0, 1), labels = c("No main", "Main"))

```

The tables below show the distribution of active main and persistent partnerships. 

## Degree distribution: overall
To calculate the degree distribution, we use data from the re-weighted WHPP survey, as we do not have data specific to HIV-positive men.
```{r degmatrix}
# Create degree distribution table
deg.matrix <- round(prop.table(svytable(~degree_main + degreecat_cas, sample_rake_all, round=FALSE)),4)

# Add margins
deg.matrix <- addmargins(deg.matrix, margin=c(1,2), sum, quiet = TRUE)
row.names(deg.matrix) <- c("No main", "Main", "Total")

kable(deg.matrix, col.names=c("0 pers", "1 pers", "2+ pers", "Total"), caption="Main and persistent degree distribution") %>% kable_styling(full_width=F, position="center") %>% row_spec(3, color="#1C91D7")  %>% column_spec(1, bold=T, color="black", width="2cm") %>% column_spec(2:5, width = "2cm") %>% column_spec(5, color="#1C91D7")

```

## Main partnership status by race/ethnicity and region
Descriptive analyses (section \@ref(explore_heterogeneity)) indicated that main partnership status varies by race/ethnicity and region, so we will include terms in the main partnership network model to account for this heterogeneity. To calculate target statistics for these terms, we need to count the number of edges in which nodes with the specified attribute appear. Thus, we need to count edges by both ego and alter attributes. However, the WHPP only measured the race/ethnicity of alters if they were the most recent partner, and did not measure the region of residence of any partners.

To obtain edge counts by race/ethnicity, we will take the following approach (see [issue #32](https://github.com/statnet/WHAMP/issues/32)): 1) obtain the row percentages for mixing from the ego's perspective, 2) multiply these row percentages by the mean degree for egos of a given race/ethnicity, 3) multiply this product by the target population size in each group. This will produce a weighted mixing matrix. 4) Balance the matrix by taking the mean of the off-diagonal elements. 5) Calculate the target statistic by adding across rows and across columns (e.g. add 1 for every time an ego with the given attribute appears in an edge and 1 for every time an alter with the given attribute appears in an edge.) This approach assumes that mixing with the unobserved ties follows the same pattern as mixing with the observed ties, and that men who did not report on their main partner have the same mixing propensities as those of the same attribute who did report on their main partner. Since we did not observe race mixing to vary by age or region, there is not an indication that we need to account for heterogeneity on these characteristics, such that this approach seems reasonable. Additionally, in section \@ref(mrp_limitations), we did not observe any differences in main partnerships reported by those with 0 compared to those with 1+ persistent partnerships, suggesting that we can use data on the most recent partnership to represent all partnerships of that type.

The tables below show the weighted and balanced mixing matrix by race/ethnicity and the implied number and proportion of times men of each racial/ethnic group appear in an edge with a main partner. For the target statistics in the model, we will multiply the proportions in the third table by twice the number of edges to scale this to the size of the network.

<span style="color:red">*Note: When we get data from MMP, the conditional row probabilities for race mixing will be based on a combination of data from the WHPP sample reweighted to the population totals for negative/unknown status men and data from the MMP*</span>
```{r degmain_race}
  #Conditional row probabilities
  racemix_main <- prop.table(svytable(~hbo + mrp_hbo, sample_rake_all[sample_rake_all$variables$mrp_type_ongoing %in% "Main"], Ntotal=dim(sample)[1], round=FALSE),1)

  #Mean degree by race - calculate on subset for which casual degree is not missing to be consistent with how the overall degree matrix is defined so total edges are consistent
  meandegXrace_main <- svyby(~degree_main, ~hbo, sample_rake_all[!is.na(sample_rake_all$variables$degreecat_cas)], svymean, na.rm=TRUE)[3]
  
  #N by race in reweighted sample (scaled back to the size of the original sample)
  nXrace <- svytable(~hbo, sample_rake_all, Ntotal=dim(sample)[1], round=FALSE)
  
  #Reweighted mixing matrix, accounting for mean degree
  racemix_main_rwt <- matrix(c(racemix_main[1,]*meandegXrace_main[1,1]*nXrace[1], racemix_main[2,]*meandegXrace_main[2,1]*nXrace[2], racemix_main[3,]*meandegXrace_main[3,1]*nXrace[3]), byrow=TRUE, nrow=3)
  racemix_main_rwt <- as.data.frame(racemix_main_rwt, row.names=c("Hispanic", "Black", "Other"))
  names(racemix_main_rwt) <- c("Hispanic", "Black", "Other")
  
  #Take average of off-diagonals to balance
  balance_avg_race <- function(x){
     balanced <- as.data.frame(matrix(c("HH"=x[1,1], "HB" = mean(c(x[1,2], x[2,1])), "HO" = mean(c(x[1,3], x[3,1])), "BH" = mean(c(x[1,2], x[2,1])), "BB" = x[2,2], "BO" = mean(c(x[2,3], x[3,2])), "OH" = mean(c(x[1,3], x[3,1])), "OB" = mean(c(x[2,3], x[3,2])), "OO" = x[3,3]), nrow=3, ncol=3, byrow=TRUE, dimnames=list(c("Hispanic", "Black", "Other"), c("Hispanic", "Black", "Other"))))
     return(balanced)
  }
  
  racemix_main_bal <- balance_avg_race(racemix_main_rwt)
  
  #Set upper triangle to mising and multiply lower off-diagonals by 2
  racemix_main_bal[1,2] <- NA
  racemix_main_bal[1,3] <- NA
  racemix_main_bal[2,3] <- NA
  racemix_main_bal[2,1] <- racemix_main_bal[2,1]*2
  racemix_main_bal[3,1] <- racemix_main_bal[3,1]*2
  racemix_main_bal[3,2] <- racemix_main_bal[3,2]*2
  
  #Count nodes in main partnerships by race
  inmainXrace <- data.frame(t(c("Hispanic" = sum(racemix_main_bal[1,], na.rm=TRUE) + sum(racemix_main_bal[,1], na.rm=TRUE), "Black" = sum(racemix_main_bal[2,], na.rm=TRUE) + sum(racemix_main_bal[,2], na.rm=TRUE), "Other" = sum(racemix_main_bal[3,], na.rm=TRUE) + sum(racemix_main_bal[,3], na.rm=TRUE))))
 
  #Calculate the proportion of nodes in main partnerships of each race
  prop.inmainXrace <- inmainXrace/sum(inmainXrace)
  
  #Save this as the parameter vector that will be used to calculate the target statistic by multiplying it by twice the total number of main edges in the network
  save(prop.inmainXrace, file="Data/nodefactor_main_race.Rdata")
  
#Make kables 
kable(racemix_main_bal, caption="Mixing matrix by race/ethnicity (edge counts)", align=c("c", "c", "c"), digits=c(1, 1, 1)) %>% kable_styling(full_width=F, position="center") %>% column_spec(1, bold=T, color="black", width="2cm") %>% column_spec(2:4, width = "2cm")

kable(inmainXrace, caption="Number of times men appear in main edges by race/ethnicity", align=c("c", "c", "c"), digits=c(1, 1, 1)) %>% kable_styling(full_width=F, position="center")  %>% column_spec(1:3, width = "2cm")

kable(prop.inmainXrace, caption="Proportion of nodes in main partnerships in each racial/ethnic group", align=c("c", "c", "c"), digits=c(4, 4, 4)) %>% kable_styling(full_width=F, position="center")  %>% column_spec(1:3, width = "2cm")

```

As we do not have data on the region of residence of alters, we will make assumptions about regional mixing by partner type (see [issue #32](https://github.com/statnet/WHAMP/issues/32)). We will assume that main partnerships occur only with men in the same region. For persistent and instantaneous partnerships, we will run sensitivity analyses with the proportion of partnerships within-region set to 0.7, 0.8, and 0.9. As exploratory analyses indicated regional heterogeneity only in main partnership formation (section \@ref(explore_heterogeneity)), we will only address main partnerships in this section.

```{r degmain_region}
  #Conditional row probabilities - set a priori to assume perfect homophily
  regionmix_main <- rbind("KC" = c(1, 0, 0), "OW" =  c(0, 1, 0), 
                                     "EW" =  c(0, 0, 1))
  
  #Mean degree by region - calculate on subset for which casual degree is not missing to be consistent with how the overall degree matrix is defined so total edges are consistent
  meandegXregion_main <- svyby(~degree_main, ~region, sample_rake_all[!is.na(sample_rake_all$variables$degreecat_cas)], svymean, na.rm=TRUE)[3]
  
  #N by region in reweighted sample (scaled back to the size of the original sample)
  nXregion <- svytable(~region, sample_rake_all, Ntotal=dim(sample)[1], round=FALSE)
  
  #Reweighted mixing matrix (adjusted for mean degree)
  regionmix_main_rwt <- matrix(c(regionmix_main[1,]*meandegXregion_main[1,1]*nXregion[1], regionmix_main[2,]*meandegXregion_main[2,1]*nXregion[2], regionmix_main[3,]*meandegXregion_main[3,1]*nXregion[3]), byrow=TRUE, nrow=3)
  regionmix_main_rwt <- as.data.frame(regionmix_main_rwt, row.names=c("King", "Western", "Eastern"))
  names(regionmix_main_rwt) <- c("King", "Western", "Eastern")
  
  #Take average of off-diagonals to balance
  balance_avg_region <- function(x){
     balanced <- as.data.frame(matrix(c("KC.KC"=x[1,1], "KC.OW" = mean(c(x[1,2], x[2,1])), "KC.EW" = mean(c(x[1,3], x[3,1])), "OW.KC" = mean(c(x[1,2], x[2,1])), "OW.OW" = x[2,2], "OW.EW" = mean(c(x[2,3], x[3,2])), "EW.KC" = mean(c(x[1,3], x[3,1])), "EW.OW" = mean(c(x[2,3], x[3,2])), "EW.EW" = x[3,3]), nrow=3, ncol=3, byrow=TRUE, dimnames=list(c("King County", "Other western WA", "Eastern WA"), c("King County", "Other western WA", "Eastern WA"))))
     return(balanced)
  }
  
  regionmix_main_bal <- balance_avg_region(regionmix_main_rwt)
  
  #Set upper triangle to mising and multiply lower off-diagonals by 2
  regionmix_main_bal[1,2] <- NA
  regionmix_main_bal[1,3] <- NA
  regionmix_main_bal[2,3] <- NA
  regionmix_main_bal[2,1] <- regionmix_main_bal[2,1]*2
  regionmix_main_bal[3,1] <- regionmix_main_bal[3,1]*2
  regionmix_main_bal[3,2] <- regionmix_main_bal[3,2]*2
  
  #Count nodes in main partnerships by region
  inmainXregion <- data.frame(t(c("King_County" = sum(regionmix_main_bal[1,], na.rm=TRUE) + sum(regionmix_main_bal[,1], na.rm=TRUE), "Other_western" = sum(regionmix_main_bal[2,], na.rm=TRUE) + sum(regionmix_main_bal[,2], na.rm=TRUE), "Eastern" = sum(regionmix_main_bal[3,], na.rm=TRUE) + sum(regionmix_main_bal[,3], na.rm=TRUE))))
 
  #Calculate the proportion of nodes in main partnerships of each region
  prop.inmainXregion <- inmainXregion/sum(inmainXregion)
  
  #Save this as the parameter vector that will be used to calculate the target statistic by multiplying it by twice the total number of main edges in the network
  save(prop.inmainXregion, file="Data/nodefactor_main_region.Rdata")
  
#Make kables 
kable(regionmix_main_bal, caption="Mixing matrix by region/ethnicity (edge counts)", align=c("c", "c", "c"), digits=c(1, 1, 1)) %>% kable_styling(full_width=F, position="center") %>% column_spec(1, bold=T, color="black", width="2cm") %>% column_spec(2:4, width = "2cm")

kable(inmainXregion, caption="Number of times men appear in main edges by region/ethnicity", align=c("c", "c", "c"), digits=c(1, 1, 1), col.names = c("King County", "Other Western WA", "Eastern WA")) %>% kable_styling(full_width=F, position="center")  %>% column_spec(1:3, width = "3.5cm")

kable(prop.inmainXregion, caption="Proportion of nodes in main partnerships in each racial/ethnic group", align=c("c", "c", "c"), digits=c(4, 4, 4), col.names = c("King County", "Other Western WA", "Eastern WA")) %>% kable_styling(full_width=F, position="center")  %>% column_spec(1:3, width = "3.5cm")

```

## Persistent partnership status by age
In descriptive analyses (section \@ref(explore_heterogeneity)), men aged 40-49 appeared to have a higher likelihood of reporting persistent partners, concurrent persistent partners, and persistent partners concurrent with a main partner. In the model (in sensitivity analyses), we will repersent this by including a `nodefactor` term for age 40-49 in the persistent formation model to allow men aged 40-49 to have a higher probability of forming persistent ties, which will in turn result in more concurrent persistent partnerships.

To obtain edge counts by age, we will take the approach described above. The tables below show the lower triangle of a weighted and balanced mixing matrix by age and the implied number and proportion of times men of each age group appear in an edge with a persistent partner. For the target statistics in the model, we will scale this to the size of the network.

<span style="color:red">*Note: When we get data from MMP, the conditional row probabilities for age mixing will be based on a combination of data from the WHPP sample reweighted to the population totals for negative/unknown status men and data from the MMP*</span>

```{r degpers_age40to49}
#Define indicator of age 40-49 and MRP age 40-49
sample_rake_all$variables$age40to49 <- ifelse(sample_rake_all$variables$age %in% c(40:49), 1,
                                              ifelse(!is.na(sample_rake_all$variables$age), 0,
                                                     NA))

sample_rake_all$variables$mrp_age40to49 <- ifelse(sample_rake_all$variables$mrp_ageinyears_approx %in% c(40:49), 1,
                                              ifelse(!is.na(sample_rake_all$variables$mrp_ageinyears_approx), 0,
                                                     NA))

#Conditional row probabilities
  agemix_pers <- prop.table(svytable(~age40to49 + mrp_age40to49, sample_rake_all[sample_rake_all$variables$mrp_type_ongoing %in% "Persistent"], Ntotal=dim(sample)[1], round=FALSE),1)

  #Mean degree by age - calculate on subset for which main degree is not missing to be consistent with how the overall degree matrix is defined so total edges are consistent
    #Make persistent degree indicator numeric
    sample_rake_all$variables$degpers <- ifelse(sample_rake_all$variables$degreecat_cas %in% "None", 0,
                                              ifelse(sample_rake_all$variables$degreecat_cas %in% "One", 1,
                                              ifelse(sample_rake_all$variables$degreecat_cas %in% "Two or more", 2,
                                                     NA)))
    
    meandegXage_pers <- svyby(~degpers, ~age40to49, sample_rake_all[!is.na(sample_rake_all$variables$degree_main)], svymean, na.rm=TRUE)[2]
  
  #N by race in reweighted sample (scaled back to the size of the original sample)
  nXage <- svytable(~age40to49, sample_rake_all, Ntotal=dim(sample)[1], round=FALSE)
  
  #Reweighted mixing matrix, accounting for mean degree
  agemix_pers_rwt <- matrix(c(agemix_pers[1,]*meandegXage_pers[1,1]*nXage[1], agemix_pers[2,]*meandegXage_pers[2,1]*nXage[2]), byrow=TRUE, nrow=2)
  agemix_pers_rwt <- as.data.frame(agemix_pers_rwt, row.names=c("Other ages", "40-49"))
  names(agemix_pers_rwt) <- c("Other ages", "40-49")
  
  #Take average of off-diagonals to balance
  balance_avg_age <- function(x){
     balanced <- as.data.frame(matrix(c("OO"=x[1,1], "O4" = mean(c(x[1,2], x[2,1])), "4O" = mean(c(x[1,2], x[2,1])), "44" = x[2,2]), nrow=2, ncol=2, byrow=TRUE, dimnames=list(c("Other ages", "40-49"), c("Other ages", "40-49"))))
     return(balanced)
  }
  
  agemix_pers_bal <- balance_avg_age(agemix_pers_rwt)
  
  #Set upper triangle to mising and multiply lower off-diagonal by 2
  agemix_pers_bal[1,2] <- NA
  agemix_pers_bal[2,1] <- agemix_pers_bal[2,1]*2
  
  #Count nodes in main partnerships by age
  inpersXage <- data.frame(t(c("Other.ages" = sum(agemix_pers_bal[1,], na.rm=TRUE) + sum(agemix_pers_bal[,1], na.rm=TRUE), "40to49" = sum(agemix_pers_bal[2,], na.rm=TRUE) + sum(agemix_pers_bal[,2], na.rm=TRUE))))
 
  #Calculate the proportion of nodes in main partnerships of each race
  prop.inpersXage <- inpersXage/sum(inpersXage)
  
  #Save this as the parameter vector that will be used to calculate the target statistic by multiplying it by twice the total number of main edges in the network
  save(prop.inpersXage, file="Data/nodefactor_pers_age.Rdata")
  
#Make kables 
kable(agemix_pers_bal, caption="Mixing matrix by age (edge counts)", align=c("c", "c"), digits=c(1, 1)) %>% kable_styling(full_width=F, position="center") %>% column_spec(1, bold=T, color="black", width="2cm") %>% column_spec(2:3, width = "2cm")

kable(inpersXage, caption="Number of times men appear in persistent edges by age", align=c("c", "c"), digits=c(1, 1), col.names = c("Other ages", "40 to 49")) %>% kable_styling(full_width=F, position="center")  %>% column_spec(1:2, width = "3cm")

kable(prop.inpersXage, caption="Proportion of nodes in persistent partnerships in each age group", align=c("c", "c"), digits=c(4, 4), col.names = c("Other ages", "40 to 49")) %>% kable_styling(full_width=F, position="center")  %>% column_spec(1:2, width = "3cm")

```

## Concurrency
Overall, `r round(100*prop.table(svytable(~concurrent, sample_rake_all, round=FALSE)), 2)[2]`% of the re-weighted sample reported one or more concurrent partners. `r round(100*sum(prop.table(svytable(~degree_main + degreecat_cas, sample_rake_all, round=FALSE))[,3]), 2)`% reported concurrent persistent partners, and `r round(100*prop.table(svytable(~degree_main + anypers, sample_rake_all, round=FALSE)), 2)[2,2]`% reported concurrent main and persistent partnerships.