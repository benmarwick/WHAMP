# Momentary degree and concurrency {#degree}
```{r, echo=FALSE, include=FALSE}
####################################################################################
# Setup
####################################################################################
#-----------------------------------------------------------------------------------
# Load packages
#-----------------------------------------------------------------------------------

    library("tidyverse")
    library("ggplot2")
    library("survey")
    library("knitr")
    library("xtable")
    library("kableExtra")

#-----------------------------------------------------------------------------------
# Load data
#-----------------------------------------------------------------------------------
    load(file="Data/InternetSurveySample.Rdata")
    load(file="Data/InternetSurvey_reweighted_all.Rdata")
    load(file="Data/InternetSurvey_reweighted_neg.Rdata")

# Set options
    opts_chunk$set(echo=FALSE, message=FALSE, warning=FALSE)
    options(knitr.table.format = "html") 
  
#-----------------------------------------------------------------------------------
# Data manipulation
#-----------------------------------------------------------------------------------

# Change degree_main variable to factor and add labels have character labels
sample_rake_all$variables$degree_main <- factor(sample_rake_all$variables$degree_main, levels = c(0, 1), labels = c("No main", "Main"))
    
#Define indicator of age 40-49 and MRP age 40-49
sample_rake_all$variables$age40to49 <- ifelse(sample_rake_all$variables$age %in% c(40:49), 1,
                                              ifelse(!is.na(sample_rake_all$variables$age), 0,
                                                     NA))

sample_rake_all$variables$mrp_age40to49 <- ifelse(sample_rake_all$variables$mrp_ageinyears_approx %in% c(40:49), 1,
                                              ifelse(!is.na(sample_rake_all$variables$mrp_ageinyears_approx), 0,
                                                     NA))

```

Several model inputs are calculated from data on the distribution of active main and persistent partnerships and instantaneous partnerships in the past year. These include patterns of race and age mixing, cross-network degree distributions, and rates of instantaneous partnerships. Adjustments made to balance the mixing matrices modify group-specific degrees, so additional adjustments are required to the cross-netowrk degree distributions and rates of instantaneous partnerships to ensure that the implied number of partnerships for each group and the total network are consistent.

Because of uncertainty about the causes of imbalances in the mixing matrices and the implications of adjusting for them, we calculate these inputs in two ways (see section \@ref(racemixing)):  

1) We will balance the mixing matrices as described in section \@ref(racemixing) and obtain the racial/ethnic group-specific mean degrees from these balanced matrices. We will then adjust the cross-network momentary degree distribution to bump the margins up or down to match these mean degrees by increasing/decreasing each cell proportionately. For example, if the mean main degree for Hispanic men from the balanced mixing matrix is 0.51 and the observed mean degree for Hispanic egos is 0.50, we will multiply the cells in the "1 main" row by 0.51/0.50 and the cells in the "0 main" row by 0.50/0.51. To adjust this matrix to match persistent degree, we will make adjustments to the "0 persistent" and "1 persistent" columns and leave the "2 persistent" column unchanged.  
2) We will use the observed egocentric data on momentary degree and the unbalanced mixing matrices. 

We will fit the model using target statistics calculated both ways and evaluate which results in networks with the features we expect, and/or how much of a difference on our outcomes the two parameter sets make (see [issue #44](https://github.com/statnet/WHAMP/issues/44)).

```{r data_manipulation_for_deg_and_mixing, include=FALSE}

####################################################
# Impute main/persistent momentary degree
####################################################

# Define numeric versions  of race/ethnicity and region to use in the `for` loops
sample_rake_all$variables$hbo.num <- as.numeric(sample_rake_all$variables$hbo)
sample_rake_all$variables$region.num <- as.numeric(sample_rake_all$variables$region)

# Define empty vectors for the imputed variables
sample_rake_all$variables$main0pers0 <- rep(NA, dim(sample_rake_all)[1])
sample_rake_all$variables$main1pers0 <- rep(NA, dim(sample_rake_all)[1])
sample_rake_all$variables$main0pers1 <- rep(NA, dim(sample_rake_all)[1])
sample_rake_all$variables$main1pers1 <- rep(NA, dim(sample_rake_all)[1])
sample_rake_all$variables$main0pers2 <- rep(NA, dim(sample_rake_all)[1])
sample_rake_all$variables$main1pers2 <- rep(NA, dim(sample_rake_all)[1])

# Deterministic imputation - set to the mean value among men of the same race/ethnicity, region, and age group
for(race in 1:3){
    for(region in 1:3){
        for(age in 0:1){
            sample_rake_all$variables$main0pers0[sample_rake_all$variables$hbo.num %in% race & sample_rake_all$variables$region.num %in% region & sample_rake_all$variables$age40to49 %in% age] <- prop.table(svytable(~degree_main + degreecat_cas, sample_rake_all[sample_rake_all$variables$hbo.num %in% race & sample_rake_all$variables$region.num %in% region & sample_rake_all$variables$age40to49 %in% age], round=FALSE))[1]
            sample_rake_all$variables$main1pers0[sample_rake_all$variables$hbo.num %in% race & sample_rake_all$variables$region.num %in% region & sample_rake_all$variables$age40to49 %in% age] <- prop.table(svytable(~degree_main + degreecat_cas, sample_rake_all[sample_rake_all$variables$hbo.num %in% race & sample_rake_all$variables$region.num %in% region & sample_rake_all$variables$age40to49 %in% age], round=FALSE))[2]
            sample_rake_all$variables$main0pers1[sample_rake_all$variables$hbo.num %in% race & sample_rake_all$variables$region.num %in% region & sample_rake_all$variables$age40to49 %in% age] <- prop.table(svytable(~degree_main + degreecat_cas, sample_rake_all[sample_rake_all$variables$hbo.num %in% race & sample_rake_all$variables$region.num %in% region & sample_rake_all$variables$age40to49 %in% age], round=FALSE))[3]
            sample_rake_all$variables$main1pers1[sample_rake_all$variables$hbo.num %in% race & sample_rake_all$variables$region.num %in% region & sample_rake_all$variables$age40to49 %in% age] <- prop.table(svytable(~degree_main + degreecat_cas, sample_rake_all[sample_rake_all$variables$hbo.num %in% race & sample_rake_all$variables$region.num %in% region & sample_rake_all$variables$age40to49 %in% age], round=FALSE))[4]
            sample_rake_all$variables$main0pers2[sample_rake_all$variables$hbo.num %in% race & sample_rake_all$variables$region.num %in% region & sample_rake_all$variables$age40to49 %in% age] <- prop.table(svytable(~degree_main + degreecat_cas, sample_rake_all[sample_rake_all$variables$hbo.num %in% race & sample_rake_all$variables$region.num %in% region & sample_rake_all$variables$age40to49 %in% age], round=FALSE))[5]
            sample_rake_all$variables$main1pers2[sample_rake_all$variables$hbo.num %in% race & sample_rake_all$variables$region.num %in% region & sample_rake_all$variables$age40to49 %in% age] <- prop.table(svytable(~degree_main + degreecat_cas, sample_rake_all[sample_rake_all$variables$hbo.num %in% race & sample_rake_all$variables$region.num %in% region & sample_rake_all$variables$age40to49 %in% age], round=FALSE))[6]
        }
    }
}

# Degree matrices using imputed data
deg.mp.H <- matrix(c(svymean(~main0pers0, sample_rake_all[sample_rake_all$variables$hbo %in% "Hispanic"]), svymean(~main0pers1, sample_rake_all[sample_rake_all$variables$hbo %in% "Hispanic"]), svymean(~main0pers2, sample_rake_all[sample_rake_all$variables$hbo %in% "Hispanic"]), svymean(~main1pers0, sample_rake_all[sample_rake_all$variables$hbo %in% "Hispanic"]), svymean(~main1pers1, sample_rake_all[sample_rake_all$variables$hbo %in% "Hispanic"]), svymean(~main1pers2, sample_rake_all[sample_rake_all$variables$hbo %in% "Hispanic"])), byrow=TRUE, nrow=2)

deg.mp.B <- matrix(c(svymean(~main0pers0, sample_rake_all[sample_rake_all$variables$hbo %in% "Black"]), svymean(~main0pers1, sample_rake_all[sample_rake_all$variables$hbo %in% "Black"]), svymean(~main0pers2, sample_rake_all[sample_rake_all$variables$hbo %in% "Black"]), svymean(~main1pers0, sample_rake_all[sample_rake_all$variables$hbo %in% "Black"]), svymean(~main1pers1, sample_rake_all[sample_rake_all$variables$hbo %in% "Black"]), svymean(~main1pers2, sample_rake_all[sample_rake_all$variables$hbo %in% "Black"])), byrow=TRUE, nrow=2)

deg.mp.O <- matrix(c(svymean(~main0pers0, sample_rake_all[sample_rake_all$variables$hbo %in% "Other"]), svymean(~main0pers1, sample_rake_all[sample_rake_all$variables$hbo %in% "Other"]), svymean(~main0pers2, sample_rake_all[sample_rake_all$variables$hbo %in% "Other"]), svymean(~main1pers0, sample_rake_all[sample_rake_all$variables$hbo %in% "Other"]), svymean(~main1pers1, sample_rake_all[sample_rake_all$variables$hbo %in% "Other"]), svymean(~main1pers2, sample_rake_all[sample_rake_all$variables$hbo %in% "Other"])), byrow=TRUE, nrow=2)

deg.mp.KC <- matrix(c(svymean(~main0pers0, sample_rake_all[sample_rake_all$variables$region %in% "King County"]), svymean(~main0pers1, sample_rake_all[sample_rake_all$variables$region %in% "King County"]), svymean(~main0pers2, sample_rake_all[sample_rake_all$variables$region %in% "King County"]), svymean(~main1pers0, sample_rake_all[sample_rake_all$variables$region %in% "King County"]), svymean(~main1pers1, sample_rake_all[sample_rake_all$variables$region %in% "King County"]), svymean(~main1pers2, sample_rake_all[sample_rake_all$variables$region %in% "King County"])), byrow=TRUE, nrow=2)
    
deg.mp.OW <- matrix(c(svymean(~main0pers0, sample_rake_all[sample_rake_all$variables$region %in% "Western WA"]), svymean(~main0pers1, sample_rake_all[sample_rake_all$variables$region %in% "Western WA"]), svymean(~main0pers2, sample_rake_all[sample_rake_all$variables$region %in% "Western WA"]), svymean(~main1pers0, sample_rake_all[sample_rake_all$variables$region %in% "Western WA"]), svymean(~main1pers1, sample_rake_all[sample_rake_all$variables$region %in% "Western WA"]), svymean(~main1pers2, sample_rake_all[sample_rake_all$variables$region %in% "Western WA"])), byrow=TRUE, nrow=2)
    
deg.mp.EW <- matrix(c(svymean(~main0pers0, sample_rake_all[sample_rake_all$variables$region %in% "Eastern WA"]), svymean(~main0pers1, sample_rake_all[sample_rake_all$variables$region %in% "Eastern WA"]), svymean(~main0pers2, sample_rake_all[sample_rake_all$variables$region %in% "Eastern WA"]), svymean(~main1pers0, sample_rake_all[sample_rake_all$variables$region %in% "Eastern WA"]), svymean(~main1pers1, sample_rake_all[sample_rake_all$variables$region %in% "Eastern WA"]), svymean(~main1pers2, sample_rake_all[sample_rake_all$variables$region %in% "Eastern WA"])), byrow=TRUE, nrow=2)

deg.mp.40to49 <- matrix(c(svymean(~main0pers0, sample_rake_all[sample_rake_all$variables$age40to49 %in% 1]), svymean(~main0pers1, sample_rake_all[sample_rake_all$variables$age40to49 %in% 1]), svymean(~main0pers2, sample_rake_all[sample_rake_all$variables$age40to49 %in% 1]), svymean(~main1pers0, sample_rake_all[sample_rake_all$variables$age40to49 %in% 1]), svymean(~main1pers1, sample_rake_all[sample_rake_all$variables$age40to49 %in% 1]), svymean(~main1pers2, sample_rake_all[sample_rake_all$variables$age40to49 %in% 1])), byrow=TRUE, nrow=2)

deg.mp.otherages <- matrix(c(svymean(~main0pers0, sample_rake_all[sample_rake_all$variables$age40to49 %in% 0]), svymean(~main0pers1, sample_rake_all[sample_rake_all$variables$age40to49 %in% 0]), svymean(~main0pers2, sample_rake_all[sample_rake_all$variables$age40to49 %in% 0]), svymean(~main1pers0, sample_rake_all[sample_rake_all$variables$age40to49 %in% 0]), svymean(~main1pers1, sample_rake_all[sample_rake_all$variables$age40to49 %in% 0]), svymean(~main1pers2, sample_rake_all[sample_rake_all$variables$age40to49 %in% 0])), byrow=TRUE, nrow=2)

deg.mp <- matrix(c(svymean(~main0pers0, sample_rake_all), svymean(~main0pers1, sample_rake_all), svymean(~main0pers2, sample_rake_all), svymean(~main1pers0, sample_rake_all), svymean(~main1pers1, sample_rake_all), svymean(~main1pers2, sample_rake_all)), byrow=TRUE, nrow=2)

#CHECK TO MAKE SURE THIS WORKED----
# ## Compare estimates of overall degree distribution from averages of distributions by race, region, and age----
# deg.mp1 <- round(deg.mp.H*prop.table(svytable(~hbo, sample_rake_all, round=FALSE))[1] + deg.mp.B*prop.table(svytable(~hbo, sample_rake_all, round=FALSE))[2] + deg.mp.O*prop.table(svytable(~hbo, sample_rake_all, round=FALSE))[3], 4)  
# deg.mp2 <- round(deg.mp.KC*prop.table(svytable(~region, sample_rake_all, round=FALSE))[1] + deg.mp.OW*prop.table(svytable(~region, sample_rake_all, round=FALSE))[2] + deg.mp.EW*prop.table(svytable(~region, sample_rake_all, round=FALSE))[3], 4)
# deg.mp3 <- round(deg.mp.40to49*prop.table(svytable(~age40to49, sample_rake_all, round=FALSE))[2] + deg.mp.otherages*prop.table(svytable(~age40to49, sample_rake_all, round=FALSE))[1], 4)
# deg.mp1 == deg.mp2 
# deg.mp1 == deg.mp3
# 
# ## Implied number of partnerships----
# num.edges.H <- deg.mp.H*svytable(~hbo, sample_rake_all, round=FALSE)[1]
# num.edges.B <- deg.mp.B*svytable(~hbo, sample_rake_all, round=FALSE)[2]
# num.edges.O <- deg.mp.O*svytable(~hbo, sample_rake_all, round=FALSE)[3]
# num.edges1 <- (deg.mp.H*prop.table(svytable(~hbo, sample_rake_all, round=FALSE))[1] + deg.mp.B*prop.table(svytable(~hbo, sample_rake_all, round=FALSE))[2] + deg.mp.O*prop.table(svytable(~hbo, sample_rake_all, round=FALSE))[3])*sum(weights(sample_rake_all))
# ### Main edges
# sum(num.edges.H[2,], num.edges.B[2,], num.edges.O[2,])
# sum(num.edges1[2,])
# ### Pers edges
# sum(num.edges.H[,2:3], num.edges.B[,2:3], num.edges.O[,2:3])
# sum(num.edges1[,2:3])
# 
# num.edges.KC <- deg.mp.KC*svytable(~region, sample_rake_all, round=FALSE)[1]
# num.edges.OW <- deg.mp.OW*svytable(~region, sample_rake_all, round=FALSE)[2]
# num.edges.EW <- deg.mp.EW*svytable(~region, sample_rake_all, round=FALSE)[3]
# num.edges2 <- (deg.mp.KC*prop.table(svytable(~region, sample_rake_all, round=FALSE))[1] + deg.mp.OW*prop.table(svytable(~region, sample_rake_all, round=FALSE))[2] + deg.mp.EW*prop.table(svytable(~region, sample_rake_all, round=FALSE))[3])*sum(weights(sample_rake_all))
# ### Main edges
# sum(num.edges.KC[2,], num.edges.OW[2,], num.edges.EW[2,])
# sum(num.edges2[2,])
# ### Pers edges
# sum(num.edges.KC[,2:3], num.edges.OW[,2:3], num.edges.EW[,2:3])
# sum(num.edges2[,2:3])
# 
# num.edges.40to49 <- deg.mp.40to49*svytable(~age40to49, sample_rake_all, round=FALSE)[2]
# num.edges.otherages <- deg.mp.otherages*svytable(~age40to49, sample_rake_all, round=FALSE)[1]
# num.edges3 <- (deg.mp.40to49*prop.table(svytable(~age40to49, sample_rake_all, round=FALSE))[2] + deg.mp.otherages*prop.table(svytable(~age40to49, sample_rake_all, round=FALSE))[1])*sum(weights(sample_rake_all))
# ### Main edges
# sum(num.edges.40to49[2,], num.edges.otherages[2,])
# sum(num.edges3[2,])
# ### Pers edges
# sum(num.edges.40to49[,2:3], num.edges.otherages[,2:3])
# sum(num.edges3[,2:3])
# 
# round(sum(num.edges1[2,]),4) == round(sum(num.edges2[2,]),4)
# round(sum(num.edges1[,2:3]),4) == round(sum(num.edges2[,2:3]),4)
# 
# round(sum(num.edges1[2,]),4) == round(sum(num.edges3[2,]),4)
# round(sum(num.edges1[,2:3]),4) == round(sum(num.edges3[,2:3]),4)


####################################################
# Define race and age mixing matrices for main and pers partnerships and balance them
####################################################

##MAIN PARTNERSHIPS##
#Conditional row probabilities
  racemix_main <- prop.table(svytable(~hbo + mrp_hbo, sample_rake_all[sample_rake_all$variables$mrp_type_ongoing %in% "Main"], round=FALSE),1)

  #Mean degree by race 
    meandegm.H <- sum(deg.mp.H[2,]) 
    meandegm.B <- sum(deg.mp.B[2,])
    meandegm.O <- sum(deg.mp.O[2,])
    
  #N by race in reweighted sample (scaled back to the size of the original sample) -- scaling to the total N assumes that those with missing data on degree or who didn't provide the age of their most recent partner are msising at random
    nXrace <- svytable(~hbo, sample_rake_all, Ntotal=dim(sample)[1], round=FALSE)

  #Reweighted mixing matrix, accounting for mean degree
  racemix_main_rwt <- matrix(c(racemix_main[1,]*meandegm.H*nXrace[1], racemix_main[2,]*meandegm.B*nXrace[2], racemix_main[3,]*meandegm.O*nXrace[3]), byrow=TRUE, nrow=3)
  racemix_main_rwt <- as.data.frame(racemix_main_rwt, row.names=c("Hispanic", "Black", "Other"))
  names(racemix_main_rwt) <- c("Hispanic", "Black", "Other")
  
  #Take average of off-diagonals to balance
  racemix_main_bal <- as.data.frame(matrix(c("HH"=racemix_main_rwt[1,1], "HB" = mean(c(racemix_main_rwt[1,2], racemix_main_rwt[2,1])), "HO" = mean(c(racemix_main_rwt[1,3], racemix_main_rwt[3,1])), "BH" = mean(c(racemix_main_rwt[1,2], racemix_main_rwt[2,1])), "BB" = racemix_main_rwt[2,2], "BO" = mean(c(racemix_main_rwt[2,3], racemix_main_rwt[3,2])), "OH" = mean(c(racemix_main_rwt[1,3], racemix_main_rwt[3,1])), "OB" = mean(c(racemix_main_rwt[2,3], racemix_main_rwt[3,2])), "OO" = racemix_main_rwt[3,3]), nrow=3, ncol=3, byrow=TRUE, dimnames=list(c("Hispanic", "Black", "Other"), c("Hispanic", "Black", "Other"))))
  
 ##PERS PARTNERSHIPS##
  #Conditional row probabilities - using data from both ongoing persistent and most recent one-time partners
  racemix_pers <- prop.table(svytable(~hbo + mrp_hbo, sample_rake_all[sample_rake_all$variables$mrp_type_ongoing %in% "Persistent" | sample_rake_all$variables$mrp_type_r %in% "One time"], round=FALSE),1)

#Mean degree by race/ethnicity
    meandegp.H <- sum(deg.mp.H[,2]) + 2*sum(deg.mp.H[,3])   
    meandegp.B <- sum(deg.mp.B[,2]) + 2*sum(deg.mp.B[,3]) 
    meandegp.O <- sum(deg.mp.O[,2]) + 2*sum(deg.mp.O[,3]) 

  #N by race in reweighted sample (scaled back to the size of the original sample)
  nXrace <- svytable(~hbo, sample_rake_all, Ntotal=dim(sample)[1], round=FALSE)

  #Reweighted mixing matrix, accounting for mean degree
  racemix_pers_rwt <- matrix(c(racemix_pers[1,]*meandegp.H*nXrace[1], racemix_pers[2,]*meandegp.B*nXrace[2], racemix_pers[3,]*meandegp.O*nXrace[3]), byrow=TRUE, nrow=3)
  racemix_pers_rwt <- as.data.frame(racemix_pers_rwt, row.names=c("Hispanic", "Black", "Other"))
  names(racemix_pers_rwt) <- c("Hispanic", "Black", "Other")
  
 #Take average of off-diagonals to balance
  racemix_pers_bal <- as.data.frame(matrix(c("HH"=racemix_pers_rwt[1,1], "HB" = mean(c(racemix_pers_rwt[1,2], racemix_pers_rwt[2,1])), "HO" = mean(c(racemix_pers_rwt[1,3], racemix_pers_rwt[3,1])), "BH" = mean(c(racemix_pers_rwt[1,2], racemix_pers_rwt[2,1])), "BB" = racemix_pers_rwt[2,2], "BO" = mean(c(racemix_pers_rwt[2,3], racemix_pers_rwt[3,2])), "OH" = mean(c(racemix_pers_rwt[1,3], racemix_pers_rwt[3,1])), "OB" = mean(c(racemix_pers_rwt[2,3], racemix_pers_rwt[3,2])), "OO" = racemix_pers_rwt[3,3]), nrow=3, ncol=3, byrow=TRUE, dimnames=list(c("Hispanic", "Black", "Other"), c("Hispanic", "Black", "Other"))))
  
race_mixing <- list("racemix_main_rwt" = racemix_main_rwt, "racemix_main_bal" = racemix_main_bal, "racemix_pers_rwt" = racemix_pers_rwt, "racemix_pers_bal" = racemix_pers_bal)
  
save(race_mixing, file="Data/race_mixing.Rdata")

####################################################
# Obtain mean degree from balanced matrices
####################################################

#Main mean degree by race/ethnicity
  bal.degm <- round(c(sum(racemix_main_bal[1,])/nXrace[1], sum(racemix_main_bal[2,])/nXrace[2], sum(racemix_main_bal[3,])/nXrace[3]),4)

#Persistent mean degree by race/ethnicity
    bal.degp <- round(c(sum(racemix_pers_bal[1,])/nXrace[1], sum(racemix_pers_bal[2,])/nXrace[2], sum(racemix_pers_bal[3,])/nXrace[3]), 4)




```

## Momentary degree distribution
To calculate the observed momentary degree distribution, we use data from the re-weighted WHPP survey, as we do not have data specific to HIV-positive men. To account for differential missingness on questions relating to current main and casual partnership counts, we impute values for respondents with missing data as the mean value among men who match on race/ethnicity, region, and age (40-49 vs other ages). This assumes that there is non-differential missingness, but it ensures that degree distributions by subgroup are consistent and imply the same total number of partnerships (see [issue 39](https://github.com/statnet/WHAMP/issues/39)).

```{r degmatrix_adjustment, include=FALSE}



```

### Overall
```{r degmatrix}
# Add margins to degree distribution table
deg.mp <- addmargins(deg.mp, margin=c(1,2), sum, quiet = TRUE)
row.names(deg.mp) <- c("No main", "Main", "Total")

kable(deg.mp, col.names=c("0 pers", "1 pers", "2+ pers", "Total"), caption="Main and persistent degree distribution", digits = c(4,4,4,4)) %>% kable_styling(full_width=F, position="center") %>% row_spec(3, color="#1C91D7")  %>% column_spec(1, bold=T, color="black", width="2cm") %>% column_spec(2:5, width = "2cm") %>% column_spec(5, color="#1C91D7")

```

### By race/ethnicity
To assign main and persistent degree as a nodal attribute according to race/ethnicity, region, and age, we will also need the degree distributions by these characteristics. Tables \@ref(tab:degmatrix_hisp)-\@ref(tab:degmatrix_other), below, present the momentary degree distributions by racial/ethnic group based on the data reported by egos (i.e. without adjusting for inconsistencies with the mean degrees implied by balanced mixing matrices).
```{r degmatrix_hisp}
# Add margins to degree distribution table
deg.mp.H <- addmargins(deg.mp.H, margin=c(1,2), sum, quiet = TRUE)
row.names(deg.mp.H) <- c("No main", "Main", "Total")

kable(deg.mp.H, col.names=c("0 pers", "1 pers", "2+ pers", "Total"), digits = c(4,4,4,4), caption="Main and persistent degree distribution: Hispanic men") %>% kable_styling(full_width=F, position="center") %>% row_spec(3, color="#1C91D7")  %>% column_spec(1, bold=T, color="black", width="2cm") %>% column_spec(2:5, width = "2cm") %>% column_spec(5, color="#1C91D7")

```
```{r degmatrix_black}
# Add margins to degree distribution table
deg.mp.B <- addmargins(deg.mp.B, margin=c(1,2), sum, quiet = TRUE)
row.names(deg.mp.B) <- c("No main", "Main", "Total")

kable(deg.mp.B, col.names=c("0 pers", "1 pers", "2+ pers", "Total"), digits = c(4,4,4,4), caption="Main and persistent degree distribution: Black men") %>% kable_styling(full_width=F, position="center") %>% row_spec(3, color="#1C91D7")  %>% column_spec(1, bold=T, color="black", width="2cm") %>% column_spec(2:5, width = "2cm") %>% column_spec(5, color="#1C91D7")

```
```{r degmatrix_other}
# Add margins to degree distribution table
deg.mp.O <- addmargins(deg.mp.O, margin=c(1,2), sum, quiet = TRUE)
row.names(deg.mp.O) <- c("No main", "Main", "Total")

kable(deg.mp.O, col.names=c("0 pers", "1 pers", "2+ pers", "Total"),  digits = c(4,4,4,4), caption="Main and persistent degree distribution: Other race/ethnicity men") %>% kable_styling(full_width=F, position="center") %>% row_spec(3, color="#1C91D7")  %>% column_spec(1, bold=T, color="black", width="2cm") %>% column_spec(2:5, width = "2cm") %>% column_spec(5, color="#1C91D7")

```

### By region
```{r degmatrix_KC}
# Add margins to degree distribution table
deg.mp.KC <- addmargins(deg.mp.KC, margin=c(1,2), sum, quiet = TRUE)
row.names(deg.mp.KC) <- c("No main", "Main", "Total")

kable(deg.mp.KC, col.names=c("0 pers", "1 pers", "2+ pers", "Total"),  digits = c(4,4,4,4), caption="Main and persistent degree distribution: King County") %>% kable_styling(full_width=F, position="center") %>% row_spec(3, color="#1C91D7")  %>% column_spec(1, bold=T, color="black", width="2cm") %>% column_spec(2:5, width = "2cm") %>% column_spec(5, color="#1C91D7")

```
```{r degmatrix_OW}
# Add margins to degree distribution table
deg.mp.OW <- addmargins(deg.mp.OW, margin=c(1,2), sum, quiet = TRUE)
row.names(deg.mp.OW) <- c("No main", "Main", "Total")

kable(deg.mp.OW, col.names=c("0 pers", "1 pers", "2+ pers", "Total"),  digits = c(4,4,4,4), caption="Main and persistent degree distribution: Other western WA") %>% kable_styling(full_width=F, position="center") %>% row_spec(3, color="#1C91D7")  %>% column_spec(1, bold=T, color="black", width="2cm") %>% column_spec(2:5, width = "2cm") %>% column_spec(5, color="#1C91D7")

```
```{r degmatrix_EW}
# Add margins to degree distribution table
deg.mp.EW <- addmargins(deg.mp.EW, margin=c(1,2), sum, quiet = TRUE)
row.names(deg.mp.EW) <- c("No main", "Main", "Total")

kable(deg.mp.EW, col.names=c("0 pers", "1 pers", "2+ pers", "Total"),  digits = c(4,4,4,4), caption="Main and persistent degree distribution: Eastern WA") %>% kable_styling(full_width=F, position="center") %>% row_spec(3, color="#1C91D7")  %>% column_spec(1, bold=T, color="black", width="2cm") %>% column_spec(2:5, width = "2cm") %>% column_spec(5, color="#1C91D7")

```

### By age
```{r degmatrix_otherages}
# Add margins to degree distribution table
deg.mp.otherages <- addmargins(deg.mp.otherages, margin=c(1,2), sum, quiet = TRUE)
row.names(deg.mp.otherages) <- c("No main", "Main", "Total")

kable(deg.mp.otherages, col.names=c("0 pers", "1 pers", "2+ pers", "Total"),  digits = c(4,4,4,4), caption="Main and persistent degree distribution: ages 18-39 and 50-59") %>% kable_styling(full_width=F, position="center") %>% row_spec(3, color="#1C91D7")  %>% column_spec(1, bold=T, color="black", width="2cm") %>% column_spec(2:5, width = "2cm") %>% column_spec(5, color="#1C91D7")

```
```{r degmatrix_40to49}
# Add margins to degree distribution table
deg.mp.40to49 <- addmargins(deg.mp.40to49, margin=c(1,2), sum, quiet = TRUE)
row.names(deg.mp.40to49) <- c("No main", "Main", "Total")

kable(deg.mp.40to49, col.names=c("0 pers", "1 pers", "2+ pers", "Total"),  digits = c(4,4,4,4), caption="Main and persistent degree distribution: ages 40-49") %>% kable_styling(full_width=F, position="center") %>% row_spec(3, color="#1C91D7")  %>% column_spec(1, bold=T, color="black", width="2cm") %>% column_spec(2:5, width = "2cm") %>% column_spec(5, color="#1C91D7")

```

## Nodes in main partnerships by race/ethnicity and region (target statistics for nodefactor terms)
Descriptive analyses (section \@ref(explore_heterogeneity)) indicated that main partnership status varies by race/ethnicity and region, so we will include `nodefactor` terms in the main partnership network model to account for this heterogeneity. To calculate target statistics for these terms, we need to count the number of times nodes of each attribute value appear in a main edge. If the sample was unbiased and mixing matrices were balanced, we could just multiply the mean degree for each attribute group by the number of nodes in that group. However, there are imbalances in the mixing matrices based on the reported characteristics of the most recent partner (see \@ref(notes_mixing)). 

So, to obtain degree counts by race/ethnicity, we will add across rows and across columns of the balanced mixing matrix (see \@ref(racemixing)). That is, we will add 1 for every time an ego with the given attribute appears in an edge and 1 for every time an alter with the given attribute appears in an edge. This approach assumes that mixing with the unobserved ties follows the same pattern as mixing with the observed ties, and that men who did not report on their main partner have the same mixing propensities as those of the same attribute value who did report on their main partner. Since we did not observe race mixing to vary by age or region, there is not an indication that we need to account for heterogeneity on these characteristics, such that this approach seems reasonable. Additionally, in section \@ref(mrp_limitations), we did not observe any differences in main partnerships reported by those with 0 compared to those with 1+ persistent partnerships, suggesting that we can use data on the most recent partnership to represent all partnerships of that type.

The tables below show the weighted and balanced mixing matrix by race/ethnicity and the implied number and proportion of times men of each racial/ethnic group appear in an edge with a main partner. For the target statistics in the model, we will multiply the proportions in the third table by twice the number of edges to scale this to the size of the network.

<span style="color:red">*Note: When we get data from MMP, the conditional row probabilities for race mixing will be based on a combination of data from the WHPP sample reweighted to the population totals for negative/unknown status men and data from the MMP. But may take a different approach with MMP since I will have data from more than one partnership*</span>
```{r degmain_race}
  #Conditional row probabilities
  racemix_main <- prop.table(svytable(~hbo + mrp_hbo, sample_rake_all[sample_rake_all$variables$mrp_type_ongoing %in% "Main"], round=FALSE),1)

  #Mean degree by race 
    meandegm.H <- deg.mp.H[2,4]
    meandegm.B <- deg.mp.B[2,4]
    meandegm.O <- deg.mp.O[2,4]
    
  #N by race in reweighted sample (scaled back to the size of the original sample)
    nXrace <- svytable(~hbo, sample_rake_all, Ntotal=dim(sample)[1], round=FALSE)

  #Reweighted mixing matrix, accounting for mean degree
  racemix_main_rwt <- matrix(c(racemix_main[1,]*meandegm.H*nXrace[1], racemix_main[2,]*meandegm.B*nXrace[2], racemix_main[3,]*meandegm.O*nXrace[3]), byrow=TRUE, nrow=3)
  racemix_main_rwt <- as.data.frame(racemix_main_rwt, row.names=c("Hispanic", "Black", "Other"))
  names(racemix_main_rwt) <- c("Hispanic", "Black", "Other")
  
  #Take average of off-diagonals to balance
  racemix_main_bal <- as.data.frame(matrix(c("HH"=racemix_main_rwt[1,1], "HB" = mean(c(racemix_main_rwt[1,2], racemix_main_rwt[2,1])), "HO" = mean(c(racemix_main_rwt[1,3], racemix_main_rwt[3,1])), "BH" = mean(c(racemix_main_rwt[1,2], racemix_main_rwt[2,1])), "BB" = racemix_main_rwt[2,2], "BO" = mean(c(racemix_main_rwt[2,3], racemix_main_rwt[3,2])), "OH" = mean(c(racemix_main_rwt[1,3], racemix_main_rwt[3,1])), "OB" = mean(c(racemix_main_rwt[2,3], racemix_main_rwt[3,2])), "OO" = racemix_main_rwt[3,3]), nrow=3, ncol=3, byrow=TRUE, dimnames=list(c("Hispanic", "Black", "Other"), c("Hispanic", "Black", "Other"))))

  #Count nodes in main partnerships by race (e.g. total main partnership degree by race)
  inmainXrace <- data.frame(t(c("Hispanic" = sum(racemix_main_bal[1,], na.rm=TRUE) + sum(racemix_main_bal[,1], na.rm=TRUE), "Black" = sum(racemix_main_bal[2,], na.rm=TRUE) + sum(racemix_main_bal[,2], na.rm=TRUE), "Other" = sum(racemix_main_bal[3,], na.rm=TRUE) + sum(racemix_main_bal[,3], na.rm=TRUE))))
 
  #Calculate the proportion of nodes in main partnerships of each race
  prop.inmainXrace <- inmainXrace/sum(inmainXrace)
  
#Make kables 
kable(racemix_main_bal, caption="Mixing matrix by race/ethnicity (edge counts)", align=c("c", "c", "c"), digits=c(1, 1, 1)) %>% kable_styling(full_width=F, position="center") %>% column_spec(1, bold=T, color="black", width="2cm") %>% column_spec(2:4, width = "2cm")

kable(inmainXrace, caption="Number of times men appear in main edges by race/ethnicity", align=c("c", "c", "c"), digits=c(1, 1, 1)) %>% kable_styling(full_width=F, position="center")  %>% column_spec(1:3, width = "2cm")

kable(prop.inmainXrace, caption="Proportion of nodes in main partnerships in each racial/ethnic group", align=c("c", "c", "c"), digits=c(4, 4, 4)) %>% kable_styling(full_width=F, position="center")  %>% column_spec(1:3, width = "2cm")

```

As we do not have data on the region of residence of alters, we will make assumptions about regional mixing by partner type (see [issue #32](https://github.com/statnet/WHAMP/issues/32)). We will assume that main partnerships occur only with men in the same region. For persistent and instantaneous partnerships, we will run sensitivity analyses with the proportion of partnerships within-region set to 0.7, 0.8, and 0.9 (may also just start with two scenarios - random mixing by region for these parterships, and perfect assortativity to see how sensitive the model is to these parameters). As exploratory analyses indicated regional heterogeneity only in main partnership formation (section \@ref(explore_heterogeneity)), we will only address main partnerships in this section.

```{r degmain_region}
  #Conditional row probabilities - set a priori to assume perfect homophily
  regionmix_main <- rbind("KC" = c(1, 0, 0), "OW" =  c(0, 1, 0), 
                                     "EW" =  c(0, 0, 1))
  
  #Mean degree by region - calculate on subset for which casual degree is not missing to be consistent with how the overall degree matrix is defined so total edges are consistent
    meandegm.KC <- deg.mp.KC[2,4]
    meandegm.OW <- deg.mp.OW[2,4]
    meandegm.EW <- deg.mp.EW[2,4]
    
  #N by region in reweighted sample (scaled back to the size of the original sample)
  nXregion <- svytable(~region, sample_rake_all, Ntotal=dim(sample)[1], round=FALSE)
  
  #Reweighted mixing matrix (adjusted for mean degree)
  regionmix_main_rwt <- matrix(c(regionmix_main[1,]*meandegm.KC*nXregion[1], regionmix_main[2,]*meandegm.OW*nXregion[2], regionmix_main[3,]*meandegm.EW*nXregion[3]), byrow=TRUE, nrow=3)
  regionmix_main_rwt <- as.data.frame(regionmix_main_rwt, row.names=c("King", "Western", "Eastern"))
  names(regionmix_main_rwt) <- c("King", "Western", "Eastern")
  
  #Take average of off-diagonals to balance
  regionmix_main_bal <- as.data.frame(matrix(c("KC.KC"=regionmix_main_rwt[1,1], "KC.OW" = mean(c(regionmix_main_rwt[1,2], regionmix_main_rwt[2,1])), "KC.EW" = mean(c(regionmix_main_rwt[1,3], regionmix_main_rwt[3,1])), "OW.KC" = mean(c(regionmix_main_rwt[1,2], regionmix_main_rwt[2,1])), "OW.OW" = regionmix_main_rwt[2,2], "OW.EW" = mean(c(regionmix_main_rwt[2,3], regionmix_main_rwt[3,2])), "EW.KC" = mean(c(regionmix_main_rwt[1,3], regionmix_main_rwt[3,1])), "EW.OW" = mean(c(regionmix_main_rwt[2,3], regionmix_main_rwt[3,2])), "EW.EW" = regionmix_main_rwt[3,3]), nrow=3, ncol=3, byrow=TRUE, dimnames=list(c("King County", "Other western WA", "Eastern WA"), c("King County", "Other western WA", "Eastern WA"))))

  #Count nodes in main partnerships by region
  inmainXregion <- data.frame(t(c("King_County" = sum(regionmix_main_bal[1,], na.rm=TRUE) + sum(regionmix_main_bal[,1], na.rm=TRUE), "Other_western" = sum(regionmix_main_bal[2,], na.rm=TRUE) + sum(regionmix_main_bal[,2], na.rm=TRUE), "Eastern" = sum(regionmix_main_bal[3,], na.rm=TRUE) + sum(regionmix_main_bal[,3], na.rm=TRUE))))
 
  #Calculate the proportion of nodes in main partnerships of each region
  prop.inmainXregion <- inmainXregion/sum(inmainXregion)
  
#Make kables 
kable(regionmix_main_bal, caption="Mixing matrix by region/ethnicity (edge counts)", align=c("c", "c", "c"), digits=c(1, 1, 1)) %>% kable_styling(full_width=F, position="center") %>% column_spec(1, bold=T, color="black", width="2cm") %>% column_spec(2:4, width = "2cm")

kable(inmainXregion, caption="Number of times men appear in main edges by region/ethnicity", align=c("c", "c", "c"), digits=c(1, 1, 1), col.names = c("King County", "Other Western WA", "Eastern WA")) %>% kable_styling(full_width=F, position="center")  %>% column_spec(1:3, width = "3.5cm")

kable(prop.inmainXregion, caption="Proportion of nodes in main partnerships in each racial/ethnic group", align=c("c", "c", "c"), digits=c(4, 4, 4), col.names = c("King County", "Other Western WA", "Eastern WA")) %>% kable_styling(full_width=F, position="center")  %>% column_spec(1:3, width = "3.5cm")

```

## Nodes in persistent partnerships by age
In descriptive analyses (section \@ref(explore_heterogeneity)), men aged 40-49 appeared to have a higher likelihood of reporting persistent partners, concurrent persistent partners, and persistent partners concurrent with a main partner. In the model (in sensitivity analyses), we will repersent this by including a `nodefactor` term for age 40-49 in the persistent formation model to allow men aged 40-49 to have a higher probability of forming persistent ties, which will in turn result in more concurrent persistent partnerships.

To obtain edge counts by age, we will take the approach described above. For calculation of mean persistent degree, we will assume that all men with 2+ persistent partners have only 2 partners, as the network model caps persistent partnerships at this level.  The tables below show the weighted, balanced mixing matrix by age and the implied number and proportion of times men of each age group appear in an edge with a persistent partner. For the target statistics in the model, we will scale this to the size of the network.

<span style="color:red">*Note: When we get data from MMP, the conditional row probabilities for age mixing will be based on a combination of data from the WHPP sample reweighted to the population totals for negative/unknown status men and data from the MMP*</span>

```{r degpers_age40to49}
#Conditional row probabilities
  agemix_pers <- prop.table(svytable(~age40to49 + mrp_age40to49, sample_rake_all[sample_rake_all$variables$mrp_type_ongoing %in% "Persistent"], round=FALSE),1)

  #Mean degree by age - assume those with 2+ pers partners had 2 partners
    meandegp.otherages <- deg.mp.otherages[3,2] + 2*deg.mp.otherages[3,3]
    meandegp.40to49 <- deg.mp.40to49[3,2] + 2*deg.mp.40to49[3,3]
  
  #N by race in reweighted sample (scaled back to the size of the original sample)
  nXage <- svytable(~age40to49, sample_rake_all, Ntotal=dim(sample)[1], round=FALSE)
  
  #Reweighted mixing matrix, accounting for mean degree
  agemix_pers_rwt <- matrix(c(agemix_pers[1,]*meandegp.otherages*nXage[1], agemix_pers[2,]*meandegp.40to49*nXage[2]), byrow=TRUE, nrow=2)
  agemix_pers_rwt <- as.data.frame(agemix_pers_rwt, row.names=c("Other ages", "40-49"))
  names(agemix_pers_rwt) <- c("Other ages", "40-49")
  
  #Take average of off-diagonals to balance
     agemix_pers_bal <- as.data.frame(matrix(c("OO"=agemix_pers_rwt[1,1], "O4" = mean(c(agemix_pers_rwt[1,2], agemix_pers_rwt[2,1])), "4O" = mean(c(agemix_pers_rwt[1,2], agemix_pers_rwt[2,1])), "44" = agemix_pers_rwt[2,2]), nrow=2, ncol=2, byrow=TRUE, dimnames=list(c("Other ages", "40-49"), c("Other ages", "40-49"))))
  
  #Count nodes in persistent partnerships by age (note this double-counts people who have 2 pers partnesrhips)
  inpersXage <- data.frame(t(c("Other.ages" = sum(agemix_pers_bal[1,], na.rm=TRUE) + sum(agemix_pers_bal[,1], na.rm=TRUE), "40to49" = sum(agemix_pers_bal[2,], na.rm=TRUE) + sum(agemix_pers_bal[,2], na.rm=TRUE))))
 
  #Calculate the proportion of nodes in main partnerships of each race
  prop.inpersXage <- inpersXage/sum(inpersXage)
  
#Make kables 
kable(agemix_pers_bal, caption="Mixing matrix by age (edge counts)", align=c("c", "c"), digits=c(1, 1)) %>% kable_styling(full_width=F, position="center") %>% column_spec(1, bold=T, color="black", width="2cm") %>% column_spec(2:3, width = "2cm")

kable(inpersXage, caption="Number of times men appear in persistent edges by age", align=c("c", "c"), digits=c(1, 1), col.names = c("Other ages", "40 to 49")) %>% kable_styling(full_width=F, position="center")  %>% column_spec(1:2, width = "3cm")

kable(prop.inpersXage, caption="Proportion of nodes in persistent partnerships in each age group", align=c("c", "c"), digits=c(4, 4), col.names = c("Other ages", "40 to 49")) %>% kable_styling(full_width=F, position="center")  %>% column_spec(1:2, width = "3cm")

```

## Concurrency
Overall, `r round(100*sum(deg.mp[1,3], deg.mp[2,2], deg.mp[2,3]), 2)`% of the re-weighted sample reported one or more concurrent partners. `r round(100*sum(deg.mp[1,3], deg.mp[2,3]), 2)`% reported concurrent persistent partners, and `r round(100*sum(deg.mp[2,2], deg.mp[2,3]), 2)`% reported concurrent main and persistent partnerships.

```{r include=FALSE}
# Save parameters
degree <- list(deg.mp = deg.mp, deg.mp.H = deg.mp.H, deg.mp.B = deg.mp.B, deg.mp.O = deg.mp.O, deg.mp.KC = deg.mp.KC, deg.mp.OW = deg.mp.OW, deg.mp.EW = deg.mp.EW, deg.mp.otherages = deg.mp.otherages, deg.mp.40to49 = deg.mp.40to49)
save(degree, file="Data/degreedists.Rdata")

nodefactor_mp <- list(prop.inmainXrace = prop.inmainXrace, prop.inmainXregion = prop.inmainXregion, prop.inpersXage = prop.inpersXage)
save(nodefactor_mp, file="Data/nodefactor_mp.Rdata")
